<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Service View</title>

<style>
/* === REUSE VISUAL STYLES (copied from editor/viewer) === */
body{
  margin:0;
  background:#fff;
  font-family:Georgia,"Times New Roman",serif;
  color:#111;
}

.wrap{
  max-width:900px;
  margin:24px auto;
  padding:12px;
}

.viewer{
  column-count:2;
  column-gap:8mm;
}

.header-box{
  column-span:all;
  -webkit-column-span:all;
  border:1px solid #dce2ea;
  border-radius:12px;
  padding:14px 16px;
  margin-bottom:16px;
  text-align:center;
}

.section-box{
  border:1px solid #dce2ea;
  border-radius:12px;
  margin:12px 0;
  break-inside:auto;
  page-break-inside:auto;
}

.section-head{
  padding:14px 16px 4px 16px;
  position:relative;
}

.section-title{
  font-family:system-ui,-apple-system,"Segoe UI",Roboto,Arial,sans-serif;
  font-weight:700;
  color:#1f6feb;
}

.section-body{
  padding:0 16px 10px 16px;
}

pre{
  font-family:"Courier New",Courier,monospace;
  font-size:16px;
  line-height:1.3;
  margin:2px 0;
  white-space:pre;
}

.service-break{
  break-after:page;
  page-break-after:always;
  height:0;
}

/* Print */
@media print{
  body{margin:12mm;}
  .viewer{column-gap:8mm;}
  @page{size:Letter;margin:12mm;}
}
</style>
</head>

<body class="service-view">
<div class="wrap">
  <div id="serviceOutput" class="viewer"></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/lz-string@1.5.0/libs/lz-string.min.js"></script>

<script>
/* ================= PURE HELPERS (copied safely) ================= */

const NOTES=['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
const FLAT_EQ={Db:'C#',Eb:'D#',Gb:'F#',Ab:'G#',Bb:'A#'};

function normalizeKey(k){
  if(!k) return null;
  const m=k.trim().match(/^([A-G])([#b]?)(m?)$/i);
  if(!m) return null;
  let r=m[1].toUpperCase(), a=m[2]||'', min=m[3]?'m':'';
  let full=r+a;
  if(FLAT_EQ[full]) full=FLAT_EQ[full];
  return full+min;
}

function computeSemitoneDiff(a,b){
  const na=normalizeKey(a), nb=normalizeKey(b);
  if(!na||!nb) return 0;
  const i1=NOTES.indexOf(na.replace(/m$/,'')),
        i2=NOTES.indexOf(nb.replace(/m$/,''));
  let d=i2-i1;
  if(d>6)d-=12;
  if(d<-6)d+=12;
  return d;
}

function applyTransposeToText(text,steps){
  return text.replace(/\[([^\]]+)\]/g,(_,ch)=>
    '['+ch.split(/\s+/).map(t=>{
      const m=t.match(/^([A-G])([#b])?(.*)$/);
      if(!m) return t;
      let full=m[1]+(m[2]||'');
      if(FLAT_EQ[full]) full=FLAT_EQ[full];
      let i=NOTES.indexOf(full);
      if(i<0) return t;
      let ni=(i+steps)%12; if(ni<0) ni+=12;
      return NOTES[ni]+(m[3]||'');
    }).join(' ')+']'
  );
}

function splitHeaderBlock(raw){
  const s=raw.indexOf('{start_header}'),
        e=raw.indexOf('{end_header}');
  if(s!==-1 && e!==-1 && e>s){
    return {
      header:raw.slice(s+15,e),
      body:raw.slice(0,s)+raw.slice(e+13),
      hasExplicit:true
    };
  }
  return {header:null,body:raw,hasExplicit:false};
}

function parseMetaFields(text){
  const g=t=>{const m=text.match(new RegExp(`\\{${t}:\\s*(.*?)\\}`,'i'));return m?m[1]:null;}
  return{title:g('title'),subtitle:g('subtitle'),key:g('key')};
}

function renderHeaderRaw(header,meta,serviceKey){
  let html='<div class="header-box">';
  if(header){
    header.split('\n').forEach(l=>{
      const m=l.match(/^\{([^:}]+):\s*(.*?)\}$/);
      if(!m) return;
      if(m[1]==='title') html+=`<h2>${m[2]}</h2>`;
      if(m[1]==='subtitle') html+=`<div><em>${m[2]}</em></div>`;
    });
  }else if(meta){
    if(meta.title) html+=`<h2>${meta.title}</h2>`;
    if(meta.subtitle) html+=`<div><em>${meta.subtitle}</em></div>`;
  }
  if(serviceKey){
    html+=`<div style="margin-top:6px;font-size:14px;color:#666">Key: ${serviceKey}</div>`;
  }
  html+='</div>';
  return html;
}

function parseChordProBody(text){
  return text.split('\n').map(l=>{
    if(!l.trim()) return '';
    if(l.startsWith('{comment')){
      return `<div class="section-box"><div class="section-head"><div class="section-title">${l.replace(/\{.*?:|\}/g,'')}</div></div></div>`;
    }
    return `<pre>${l}</pre>`;
  }).join('');
}

/* ================= SERVICE RENDERER ================= */

function renderSong(rawText,serviceKey){
  const m=rawText.match(/\{key:\s*([A-G][#b]?m?)\}/i);
  const originalKey=m?m[1]:null;
  const steps=(originalKey&&serviceKey)?computeSemitoneDiff(originalKey,serviceKey):0;

  const {header,body,hasExplicit}=splitHeaderBlock(rawText);
  const meta=parseMetaFields(rawText);

  const bodyT=applyTransposeToText(body,steps);
  return `
    ${renderHeaderRaw(header,hasExplicit?null:meta,serviceKey)}
    ${parseChordProBody(bodyT)}
  `;
}

/* ================= LOAD FROM URL ================= */

const params=new URLSearchParams(location.search);
const setParam=params.get('set');
if(!setParam){
  document.getElementById('serviceOutput').innerHTML='<p>No service set.</p>';
}else{
  const decoded=LZString.decompressFromBase64(decodeURIComponent(setParam));
  const SERVICE_SET=JSON.parse(decoded);

  const out=document.getElementById('serviceOutput');
  out.innerHTML='';

  SERVICE_SET.forEach((song,i)=>{
    out.innerHTML+=renderSong(song.cho,song.key);
    if(i<SERVICE_SET.length-1){
      out.innerHTML+='<div class="service-break"></div>';
    }
  });
}
</script>
</body>
</html>
